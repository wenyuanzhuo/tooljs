
## 预解析
要计算延迟编译函数本身是否需要上下文，我们需要再次执行范围解析：我们需要知道嵌套在惰性编译函数中的函数是否引用了惰性函数声明的变量。我们可以通过重新预先准备这些功能来解决这个问题。这正是V8在V8 v6.3 / Chrome 63上所做的。虽然这在性能方面并不理想，因为它使源大小和解析成本之间的关系非线性：我们会将函数预先分析为嵌套的多次。除了动态程序的自然嵌套之外，JavaScript打包器通常将代码包装在“ 立即调用的函数表达式 ”（IIFE）中，使得大多数JavaScript程序具有多个嵌套层。

## IntersectionObserver
chorme 51+ 异步web api 交叉观察器
> 代替传统 监听scroll + 节流 处理滚动事件
```
var io = new IntersectionObserver(callback, option)
io.observe(element) // 开始观察
io.unobserve(element) // 停止观察
io.disconnect() // 关闭观察器

```
> callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）

## 浏览器 渲染
1. js 阻塞dom的解析（parse）和渲染（render）
  > - script 置于heard（添加defer) ----延时执行 domContentLoaded(dom 和css都准备好了， 很多script框架的<strong>onLoad事件都是在此事件之后</strong>)
  > - 其他script置于body底部 (等待dom解析完全，可以避免阻塞dom解析)

### css的两点作用——第一个是提供给 JavaScript 操作样式表的能力，第二为布局树的合成提供基础的样式信息
2. css阻塞js执行从而阻塞dom的解析，css同样也会阻塞dom渲染
  > - 浏览器不知道js中是否操作了css,所以遇到js(script),都会等待css的加载
  > - css加载是在另外线程
```
如果css不阻塞dom渲染 —— 后果是什么
1. dom解析完,js执行完,渲染完 ———— 此时css可能还在加载也可能cssom还未解析完，等待cssom准备好，就会重渲导致屏幕闪烁

通过css的第一点作用，js需要操作css 且浏览器不知道js中是否操作了css，所以css需要加载完 那么阻塞js执行就显而易见了
```

总结 css应该放在heard和dom并行加载，js应该放置body底部最后加载。如果是不必要的js应当defer延迟加载，非首页js应该利用前端框架模块化 动态加载

3. domInteractive domContentLoaded domComplete
> - domInteractive 表示完成全部 HTML 的解析并且 DOM 构建完毕， （重要的性能指标——构建完说明可能阻塞dom解析与dom树构建过程结束）
> - domContentLoaded 表示 DOM 与 CSSOM 皆已准备就绪， （defer 脚本执行） -> 准备渲染  jquery的ready方法，其实监听的就是 DOMContentLoaded 事件  
> - domComplete 表示所有的处理都已完成并且所有的附属资源都已经下载完毕(页面上所有的资源（图片，音频，视频等）被加载以后才会触发load事件)


## 透过动画看优化

### 显示器如何显示图像

- 帧—— 渲染一张图
- 帧率—— 一秒内渲染的帧数
- 图的来源—— 显卡前缓冲区
- 显卡—— 合成图像，将合成图像写到后缓冲区，再将后缓冲区和前缓冲区对调，以保证图的来源新鲜

显示器每秒读取前缓冲区内的帧率数的图片，显示到机器上。所以显卡处理图片的效率直接影响显示的流畅度。

### 如何生成一帧图
- 重排—— 效率最低 （比如：页面的缩放拉伸，页面内字体的大小都会导致重排），它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。
- 重绘—— 效率也很低（比如：页面元素背景颜色改变） 不用重新布局，但是仍然要绘制元素属性
- 合成—— 效率最高，在单独线程进行，不影响主线程，同时还可以采用GPU加速

### 如何进行合成操作

在chrome中，可以用三个词来概括总结：<strong>分层、分块和合成</strong>

- 分层—— 类似ps中的图层，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树，图层树的节点包含图层(节点拥有图层需要满足以下两个条件中的任意一个)，之后就是绘制图层列表（当然不是绘制图片）
> 拥有层叠上下文属性的元素会被提升为单独的一层

> 需要剪裁（clip）的地方也会被创建为图层
- 光栅化—— 通过分层绘制的图层列表，生成图片，发送至显卡后缓冲区
- 合成——合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

- 分块—— 图层分割为固定大小的图块，如果优先绘制的图块仍然很消耗时间怎么办？纹理上传
> 为什么分块？—— 页面通常很大，一个屏幕占不全，优化策略分块就展示首先靠近视窗的部分，所以切割分块，以大大加速页面的显示速度。

> 纹理上传 ? —— 先合成低分辨率图，然后在线程空闲时异步绘制原分辨率图,在图片加载优化方面也用到类似的优化策略，也就是通常看到的图片渐渐清晰的策略。

### 利用分层合成技术 绕过js高效优化代码?

在上文<strong>如何生成一帧图</strong>中，可以知道应该避免重排重绘，来生成一帧图。
> 场景——某个元素做几何形状变换、透明度变换或者一些缩放操作？

> 方案 1. js处理——涉及到 cssom树的解析-生成布局树-布局-绘制...等等整个渲染流程，效率低。

>方案 2. 分层合成处理—— 具体操作：通过以下操作告知渲染引擎通过合成线程直接处理这些特效变换，完全没有经过一般的渲染流程
```
will-change: transform;
```

通过方案2可以知道，css的动画比js动画高效很多的原因。will-change是个典型的空间换时间的方法，有因必有果，通过独立层进行合成操作，这是很占用内存的，同时这个方法处理不好会造成内存泄漏，需要合理的使用。


----------------

接下来讨论如何在页面加载完，在交互中优化代码？

### 优化js代码，减短执行时间
- 节流     防抖     异步    web worker
### 避免强制同步布局

- 改变dom元素，同时在该任务中 强制进行计算与布局操作

### 减少创建临时对象，以免频繁触发垃圾回收
- ts 保持数据结构的正确，可以减少解构创建过多临时对象

### 少使用js动画 尽量使用css合成动画， will-change合理使用
- will-change 浅析 // TODO



