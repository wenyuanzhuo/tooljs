# 透过前端动画看性能优化



### 什么是动画？
动画是指由许多帧静止的画面，以一定的速度（如每秒16张）连续播放时，肉眼因视觉残象产生错觉，而误以为画面活动的作品。概括以上的话：每秒中在显示器上播放的图片帧数达到一定数量，造成的视觉错觉。

### 显示器如何显示图像 ？

- 帧 —— 渲染一张图
- 帧率 —— 一秒内渲染的帧数
- 图的来源 —— 显卡前缓冲区
- 显卡—— 合成图像，将合成图像写到后缓冲区，再将后缓冲区和前缓冲区对调，以保证图的来源新鲜

到此用专业的话概括动画：显示器每秒读取前缓冲区内的帧率数的图片，显示到机器上。所以显卡处理图片的效率直接影响显示的流畅度，也就影响动画的效果。

### 如何生成一帧图

渲染引擎是如何生成一帧图像的，关于其中任意一帧的生成方式，有重排、重绘和合成三种方式。这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。

- 重排—— 效率最低 （比如：页面的缩放拉伸，页面内字体的大小都会导致重排），它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。
- 重绘—— 效率也很低（比如：页面元素背景颜色改变） 不用重新布局，但是仍然要绘制元素属性
- 合成—— 效率最高，在单独线程进行，不影响主线程，同时还可以采用GPU加速

由此可知：合成是最为高效的生成图的方式，所以接下来我们就来深入分析下 Chrome 浏览器是怎么实现合成操作的。Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成 ？

### 分层、分块和合成

有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，当然还有一些炫酷的 3D 动画特效。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制,将严重影响页面动画效果，造成卡顿发生。

为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？

- 分层—— 一个网页就是很多张图片叠在一起，每个图片就对应一个图层，将素材分解为多个图层的操作
- 合成—— 这些图层合并到一起的操作

小时候玩的翻纸书动画小人，相当于动画里的平移、旋转、缩放、阴影或者 Alpha 渐变。渲染引擎只要知道“纸书”（图层）的下一页是什么，然后直接盖在上一页上,也就是合成操作。而不是吧一个图层再画过一遍，这其中所要消耗的时间可想而知。这也就是为什么合成高效的原因。而且需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

-分块—— 每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度

由此涉及一些增强用户体验的方案—— 纹理上传 和 低分辨率图片骨架减少首页白屏时间

### 利用分层合成技术 绕过js高效优化代码?

在上文<strong>如何生成一帧图</strong>中，可以知道应该避免重排重绘，来生成一帧图。
> 场景——某个元素做几何形状变换、透明度变换或者一些缩放操作？

> 方案 1. js处理——涉及到 cssom树的解析-生成布局树-布局-绘制...等等整个渲染流程，效率低。

>方案 2. 分层合成处理—— 具体操作：通过以下操作告知渲染引擎通过合成线程直接处理这些特效变换，完全没有经过一般的渲染流程
```
will-change: transform;
```

通过方案2可以知道，css的动画比js动画高效很多的原因。will-change是个典型的空间换时间的方法，有因必有果，通过独立层进行合成操作，这是很占用内存的，同时这个方法处理不好会造成内存泄漏，需要合理的使用。


### 在交互阶段 优化js代码，减少页面渲染压力

滚动鼠标滚轮时页面滚动的动画效果，这样的交互场景十分的常见，但是代码短时间的重复执行，对于渲染引擎会造成不好的影响。 这里有两个方法可以减轻引擎的压力，可通过具体的场景选择具体的方式。
-节流—— 相距一定时间间隔触发一次
```
function throttle(func, wait) {
  let _this, args, timer, timestamp = 0
  const later = function() {
    timer = null
    timestamp = +new Date()
    func.apply(_this, args)
  }
  return function() {
    let now, remain
    now = +new Date()
    _this = this
    args = arguments
    remain = wait - (now - timestamp)
    if (remain <= 0) { // 第一次立即执行
      timestamp = now
      func.apply(_this, args)
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
    } else if (!timer) {
      timer = setTimeout(later,wait)
    }
  }
}
```
-防抖—— 触发行为结束后一定时间再次执行
```
function debounce(func, wait, immediate) {
  var timer
  return function () {
    var context = this
    var arg = arguments 
    
    if (timer) clearTimeout(timer)
    if (immediate) {
      var fire = !timer
      timer = setTimeout(function() {
        timer = null
      }, wait)
      if (fire) {
        func.apply(context, arg)
      }
    } else {
      timer = setTimeout(function() {
        func.apply(context, arg)
      }, wait)
    }
    
  }
}
```

#### 参考文献
https://time.geekbang.org/column/article/141842
